\chapter{Problem Formulation}

Problem Formulation


\section{Research Problems}


Software development typically involves requirements elicitation, analysis, design, coding, testing, and operation. We notice major difficulties in software development happen in the requirements elicitation phase and the coding or implementation phase.

In the requirements elicitation phase, developers have to clarify requirements, find errors or oversights in the requirements, where a lot of elbow grease is required. Then the development goes to the coding phase. Besides adding functions, developers have to review each other's code, do refactoring, and keep the codebase clean. Maintaining the codebase is another labor.



\section{Aims and Objectives}

I want to find some way to help software development go smoothly and error-free, help developers write programs faster and reduce headache in maintaining the programs.

I find it is desirable to have a tool that generates prototypes directly from requirements automatically, so that requirement engineers can run the prototype and find issues in the requirements, consult with the clients, and fix the issues as early as possible.


\begin{figure}[ht]
\begin{lstlisting}[language=diff, breaklines=true, numbers=left, xleftmargin=2em]
diff --git a/src/.../TldPatterns.java b/src/.../TldPatterns.java
old mode 100644
new mode 100755
diff --git a/src/.../Chars.java b/src/.../Chars.java
index a0cf5bd..e26dca8 100644
--- a/src/.../Chars.java
+++ b/src/.../Chars.java
@@ -43,7 +43,7 @@ import java.util.RandomAccess;
* @author Kevin Bourrillion
* @since 1
*/
- public class Chars {
+ public final class Chars {
	private Chars() {}
}
\ No newline at end of file
\end{lstlisting}
\caption{a diff file}
\label{fig:example-diff}
\end{figure}

Code review is a key in software engineering to enforce software quality, where one developer reviews another developer's code, and the code is typically in a pull request, a side branch.
I believe code review can be made easy by assigning different types of reviews to different specialists. In a version control system, a commit can be represented by a diff, and I think we can use diff to classify pull requests. \autoref{fig:example-diff} shows an example diff file, where we can see the declaration of class \code{Chars} is changed and there is no other refactoring.


\section{Relevance, Novelty and Originality}

To generate a prototype from a requirement document, I want to base my work on Yang's RM2PT. RM2PT generates vanilla Java source code, and since blockchain and smart contract are hot research topics, I want to extend RM2PT so that smart contract applications can be generated.

Another limitation of RM2PT is that it requires the requirement document to be written in a DSL. Many open source Java repositories only give the source code, but no requirement documents.
I will try to invent a technology that as long as one Java program is written in a pattern, for instance MVC, I'm able to convert it to a smart contract application.

Both {\gnudiff} and {\gitdiff} are able to show the difference character by character between two text files or commits.
Changes to multiple files can be recorded in a single diff file.
In terms of the diff format, a line starting with double at-symbol (\code{@@}) signals the starting of a hunk where the files differ.
Diff files generated by {\gitdiff} have optional hunk headers appended at the end of the \code{@@} lines.


Researchers~\cite{xu2019commit,liu2019generating} working in commit message generation gradually found neural machine translation (NMT),
which was originally used for translating a natural language to another,
excelled at translating diff to commit messages.
Such an NMT approach has two major components, the encoder and the decoder.
The encoder reads the diff and encodes it to some internal matrix representation,
then the decoder transforms the internal representation to human readable text, i.e., the commit messages.
I do not find works use NMT for commit classification.



Taking diff as algorithm input, program analysis is specialized to diff analysis.
A few works in diff analysis start to embrace machine learning techniques.
\etal{Loyola}~\cite{loyola2017neural} developed a neural network model to generate text description from diff files.
Their work relies on a lexer that divides source code into tokens,
thus it is not end-to-end machine learning.
\etal{Macho}~\cite{macho2016predicting} employed a random forest classifier and categorized commits into forward engineering, re-engineering, corrective engineering and management.

RefDiff~\cite{silva2020refdiff} and RMiner~\cite{tsantalis2018accurate} can detect refactoring types, including extract method, rename class, pull methods, etc. Nonetheless, they have to read complete content of the changed files before and after a commit in order to run a detection.

What I want to do is to use purely diff with the help of neural network. My approach does not need rigid syntactical parser, and does not read full source or complete content of a file. The output of my network is a percentage, indicating how confident my network is that the input belongs to the given type.

