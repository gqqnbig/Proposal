\chapter{Methodology}


\section{Description of methods to solve the problem}

I plan to use AI or neural network to analyze requirement documents, and eventually transform them to executable programs.
To get started I will transform to a blockchain smart contract.
I will have to analyze the characteristics of smart contract, including parallel properties and data persistence, and find out what programs can be safely transformed to smart contract.

First I will try rule-based transformation where the rules are hand-coded. Second, I will make use of neural networks to do the transformation. In addition, I will publish papers on the theory part of smart contracts as they are like distributed programs.

{\cocome} will be my first study case. I will make sure it can be correctly transformed a blockchain smart contract. Then I will evaluate my algorithm on other study cases, e.g., SLEX-Web.

To prove the conversions are sound, theories of programming languages may be studied. I will investigate theoretical differences between smart contract and traditional local programs;
look into rCOS~\cite{ke2012rcos} which is a formal model-driven engineering method for component-based software;
define some partial order by refinement calculus to prove each conversion does not break pre- and post-conditions, etc.

One challenge in data persistence of smart contract is that the API of the blockchain platform is pretty general and naive. The API treats the blockchain as a key-value store and there is no relation in objects. One object must hold an unique identifier (PK) of another object, and load the object from the chain when needed through the PK.
To implement a program in blockchain, I will add or locate PK of each entity, and add serialization support.

When a method of a smart contract is called, the results are not yet committed to the chain until miners verified the results and reached a consensus. Hence, the post-condition checking may not happen within the smart contract. I will evaluate multiple way in implementing the post-condition, including a second smart contract, checking program local states, custom consensus algorithm, and lazy evaluation.
I shall also check blockchain validation frameworks and review how other blockchain programs were implemented.

Like~\cite{tolmach2021survey} mentioned, I am better off finding a (mathematical) model for smart contract which can help describe operations on blockchain. This model is usually described in graph theory, algebra, or communicating sequential processes.

Another potential contribution in this area is to find or invent a library for saving and loading data to blockchain like Object Relational Mapping because
not all applications care the exact details of synchronizing object changes happening in memory to the blockchain.


After my conversion tool is implemented, I hope to let people use it so that I can find out how much my tool can actually save people's time, and see to what extend people have to revise the auto-generated code. Then I will list these numbers in my paper for practically proving the effectiveness of my tool.

When a prototype is generated by my tool, it is still far from being a product, as the state-of-the-art code generation systems leave holes where the system is uncertain or the operation involves  third-party API or sorting. In addition, the prototype must be refactored and improved to meet non-functional requirements, e.g., aesthetic guidelines on the GUI.

In the further coding, developers make commits which improves the system bit by bit, and each commit is essentially a diff. To process diff, neural network is again a key. I expect to use text vectorization layers to split the diff text into words, and use word embeddings to convert each word into a vector of decimals.
The remaining of the neural network can take the simplest dense layers, or more advanced convolutional neural network~\cite{albawi2017understanding}, recurrent neural network~\cite{tarwani2017survey}, long short-term memory~\cite{skovajsova2017long}, etc.

A similar evaluation is desired to measure the effectiveness of the commit analysis tool. I may divide participants into two groups, one group uses the tool and the other does not use. I will compare how much productivity increase the group using the tool has comparing to the other group.


