\chapter{Conclusions}

In this proposal, I outlined my research plan in the field of smart contract and computing theory.

Businesses and organizations are motivated to use smart contracts in their daily operations
but coding smart contracts is a big barrier even for senior developers.
Thus it is an opportunity to automatically transform conventional functional implementations to smart contracts with the help of artificial intelligence or neural networks.
RM2PT and other state-of-the-art demonstrated the possibilities of doing such a conversion despite not 100\% of code can be correctly generated.


To prove the conversions are sound, theories of programming languages will be studied. I will investigate theoretical differences between smart contract and conventional local programs,
look into ways in mapping object operations happening in memory to blockchain operations, define some partial order by refinement calculus to prove each conversion does not break pre- and post-conditions, etc.
Given a conventional application, I shall use a neural network to identify if this application is transformable to a smart contract in Hyperledger Fabric.
I have already published a paper on classifying identifier renaming from commits to a version control system, which is a cornerstone of the following classification.

I will use {\cocome} as my first study case, then test my algorithm on SLEX-Web and ECefblock. I will publish a paper on the actual transformation to smart contracts.


%In requirement engineering, having a prototype to verify the requirements reduces failings in software projects and cut costs in follow-up modifications if a requirement error was found in the implementation phase. Make a requirement prototype is still laborious, thus automatically generating a prototype from requirement documents is beneficial.
%In light of the wide adoption of blockchain technologies and smart contract by businesses, my idea in this area is to generate smart contracts from business contracts.


%After a working prototype is generated, the software development enters the implementation phase. Developers have to implement missing functions that are not auto-generatable, wrestle non-functional requirements, and constantly refactor the codebase.
%This technology takes part in the code review step and help control code quality and prevent bugs.
%Future works include classifying more revision types, e.g., method moving and bug fixing, etc.


%Only data of application that requires immutable will
%be packaged inside blocks. This helps decrease storage, replication and lookup
%costs for the developed decentralized applications.
%
%channel


%
%
%
%Code summarization is a sub-field of natural language processing (NLP),
%here the input is the program source code and the output is the summary.
%A large body of work has been carried out in this field with assorted techniques.
%Despite the fact that code summarization does not match our work in all the three aspects,
%some observations inspired us.
%
%
%
%
%Taking diff as input, program analysis is specialized to diff analysis.
%\etal{Moreno}~\cite{moreno2016arena} generated release notes by reading changes to program source code and documentations, as well as taking into consideration issues from software repositories.
%ChangeScribe~\cite{linares2015changescribe},
%ChangeDoc~\cite{huang2020learning}, and
%DeltaDoc~\cite{buse2010automatically} read diff and followed a set of rules to generate commit messages.
%None of them used machine learning, and howbeit they all processed diff,
%their goal was not to classify the diff.
%They do not accept the {\gitdiff} format which shows barely changed lines of changed files.
%
%
%
%
%
%
%
%
%
%There are existing works in the field of program analysis,
%but research is struggling to answer questions like ``Why does this method crash?'',
%To enrich the experience towards solving the broader problem of code classification,
%we carry out this experiment to tackle one specific type of code modification recognition
%--- renaming of identifiers.
%In this work, we propose a probabilistic machine-learning classification model,
%per taxonomy of~\cite{allamanis2018survey},
%to automatically identify the commits to a version-control system that only consist of identifier renaming.
%This technique is novel in that the neural network is able to read merely the diff and give a confidence value of whether it belongs to the category.
%On the contrary, the traditional way of detecting such changes is done by analyzing the full source code before and after the commit,
%which is less efficient and often complicated with partial source code.
%For typical software projects nowadays each with a lot of imported libraries,
%the ability to carry out analysis based on local partial source code is certainly an advantage.
%
%Our model can be used as a component in the Continuous Integration (CI) with a Pull-Request (PR) workflow, for instance, on GitHub Actions.
%When a developer submits a pull request, CI runs to build and test the code and can add labels to the PR.
%Our model plays a role in CI that we take the unified diff of the PR as input,
%and classify whether the diff is identifier renaming, ``yes'' or ``no''.
%Then, CI can label the PR or assign it to the corresponding code reviewers.
%For our model to work, if one commit changes multiple files,
%the changes to these files should be concatenated to a single diff file,
%as the~{\gitdiff} program does.
%
%Our work focuses on the classification of diff in a typical programming language
%--- Java diff files,
%because Java is a popular language and the syntax is relatively simple.
%We specifically target Java 7, since Java 8 and beyond have introduced many new syntactical improvements,
%which could cause complication in the parsing and needlessly shift our focus away.
%
%There is no off-the-shelf dataset of commits and labels of whether the commit is identifier renaming.
%Although \etal{Jiang} claimed their dataset contained only Java source code,
%we found it actually containing many non-Java contents.
%We filtered out non-Java code and 62K commits remain.
%To further expand the dataset, we employed the crawling GitHub tool provided by~\cite{alexandru2017replicating} to collect additional commits from top Java repos on GitHub in January 2021.
%The final dataset obtained has \num{73080} examples.
%
%We contribute in this work a probabilistic neural network classification model with diff files as input, telling whether the input is renaming or not.
%The model was tailored against the Java programming language, and
%we believe minor tweaks can allow it to work on other programming languages.
%Besides the neural network model, we also present a dataset that labels 73K Java diff files with whether they are renaming commits,
%together with a syntax analyzer for Java diff files based on {\sc antlr}.
%
%
%
%
%
%
%\begin{equation}\label{eq:sample1}
%	a^2 + b^2 = c^2
%\end{equation}
%
%\begin{equation}\label{eq:sample2}
%	\begin{dcases}
%		a + b = 2\\
%		a - b = 0
%	\end{dcases}
%	\implies
%	\begin{dcases}
%		a = 1\\
%		b = 1
%	\end{dcases}
%\end{equation}
%
%\autoref{eq:sample1} and \ref{eq:sample2} as sample equation.
%
%
%\begin{table} [h]
%	\centering
%	\caption{Sample of table.}
%	\begin{tabular}{|c|c|c|c|}
%		\hline
%		\textbf{A} & \textbf{B} & \textbf{C} & \textbf{D} \\
%		\hline
%		1 & 2 & 3 & 4 \\
%		\hline
%		5 & 6 & 7 & 8 \\
%		\hline
%	\end{tabular}
%	\label{tab:sample}
%\end{table}
%
%\autoref{tab:sample} as sample table.
%
%\begin{figure} [h]
%	\centering
%	\includegraphics[width=0.5\linewidth]{MPI.pdf}
%	\caption{MPI logo}
%	\label{fig:sample}
%\end{figure}
%
%\autoref{fig:sample} as sample figure.